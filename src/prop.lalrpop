use crate::lex::Token;
grammar<'a>;

extern {
  type Location = usize;
  type Error = usize;

  enum Token<'a> {
	"ⲗ" => Token::Abs,
	"⊥" => Token::Bot,
	"." => Token::Dot,
	"≔" => Token::Def,
	"→" => Token::Arrow,
	"↔" => Token::Iff,
	"¬" => Token::Neg,
	"⊤" => Token::Top,
	"∧" => Token::Conj,
	"∨" => Token::Disj,
	"(" => Token::LParen,
	")" => Token::RParen,
	"[" => Token::LBrack,
	"]" => Token::RBrack,
	":" => Token::Colon,
	"," => Token::Comma,
	";" => Token::Semi,
	"∴" => Token::Thus,
	"‣" => Token::CaseLeg,
	"□" => Token::QED,
	"Prop" => Token::PropT,
	"case" => Token::Case,
	fancy_name_unicode => Token::Name(<&'a str>),
	fancy_name_ascii => Token::FancyNameAscii(<&'a str>),
  }
}

name: &'a str = {
  fancy_name_unicode,
  fancy_name_ascii,
}

pub prop = Semi<Binding>;

Binding: () = {
    <_n:name> "≔" <_s:Stmt> => (),
    <_n:name> ":" <_t:Prop> "≔" <_s:Stmt> => (),
}
Stmt: () = {
  <_s: Stmt> "‣" <_t:Thus> => (),
  Thus => (),
}

Thus: () = {
  <_t:Thus> <_p: ("∴" PropOpt)> => (),
  <_t:Thus> "." <_p:PropOpt> => (),
  PropOpt
}

Semi<T>: Vec<T> = {
  <v:(<T> ";")*> <t:T?> => match t {
    None => v,
    Some(t) => {
	let mut v = v;
	v.push(t);
	v
    }
  }
}

Prop: () = {
  "¬" <_t:BinaryProp> => (),
  BinaryProp,
}

PropOpt: () = {
  Prop,
  (),
}

BinaryProp: () = {
  <_p1:BinaryProp> "∧" <_p2:Atom> => (),
  <_p1:BinaryProp> "∨" <_p2:Atom> => (),
  <_p1:BinaryProp> "→" <_p2:Atom> => (),
  <_p1:BinaryProp> "↔" <_p2:Atom> => (),
  <_p1:BinaryProp> "∧" "¬" <_p2:Atom> => (),
  <_p1:BinaryProp> "∨" "¬" <_p2:Atom> => (),
  <_p1:BinaryProp> "→" "¬" <_p2:Atom> => (),
  <_p1:BinaryProp> "↔" "¬" <_p2:Atom> => (),
  Atom,
}

Atom: () = {
  "⊤" => (),
  "(" Prop ")" => (),
  <_n:name> => (),
};

