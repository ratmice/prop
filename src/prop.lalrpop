use crate::lex::Token;
grammar<'a>;

extern {
  type Location = usize;
  type Error = usize;

  enum Token<'a> {
	"ⲗ" => Token::Abs,
	"⊥" => Token::Bot,
	"." => Token::Dot,
	"≔" => Token::Def,
	"→" => Token::Arrow,
	"↔" => Token::Iff,
	"¬" => Token::Neg,
	"⊤" => Token::Top,
	"∧" => Token::Conj,
	"∨" => Token::Disj,
	"(" => Token::LParen,
	")" => Token::RParen,
	"[" => Token::LBrack,
	"]" => Token::RBrack,
	":" => Token::Colon,
	"," => Token::Comma,
	";" => Token::Semi,
	"∴" => Token::Thus,
	"‣" => Token::CaseLeg,
	"□" => Token::QED,
	"Prop" => Token::PropT,
	"case" => Token::Case,
	fancy_name_unicode => Token::Name(<&'a str>),
	fancy_name_ascii => Token::FancyNameAscii(<&'a str>),
  }
}

name: &'a str = {
  fancy_name_unicode,
  fancy_name_ascii,
}

pub prop = Semi<Binding>;

Binding: () = {
    <n:name> "≔" <s:Stmt> => (),
    <n:name> ":" <t:Prop> "≔" <s:Stmt> => (),
}
Stmt: () = {
  <s: Stmt> "‣" <t:Thus> => (),
  Thus => (),
}

Thus: () = {
  <t:Thus> <p: ("∴" PropOpt)> => (),
  <t:Thus> "." <p:PropOpt> => (),
  PropOpt
}

Semi<T>: Vec<T> = {
  <v:(<T> ";")*> <t:T?> => match t {
    None => v,
    Some(t) => {
	let mut v = v;
	v.push(t);
	v
    }
  }
}

Prop: () = {
  "¬" <t:BinaryProp> => (),
  BinaryProp,
}

PropOpt: () = {
  Prop,
  (),
}

BinaryProp: () = {
  <p1:BinaryProp> "∧" <p2:Atom> => (),
  <p1:BinaryProp> "∨" <p2:Atom> => (),
  <p1:BinaryProp> "→" <p2:Atom> => (),
  <p1:BinaryProp> "↔" <p2:Atom> => (),
  <p1:BinaryProp> "∧" "¬" <p2:Atom> => (),
  <p1:BinaryProp> "∨" "¬" <p2:Atom> => (),
  <p1:BinaryProp> "→" "¬" <p2:Atom> => (),
  <p1:BinaryProp> "↔" "¬" <p2:Atom> => (),
  Atom,
}

Atom: () = {
  "⊤" => (),
  "(" Prop ")" => (),
  <n:name> => (),
};

